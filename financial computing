9.10
int argc, char** argv
argc: number of arguments,  argv: arguments store list  argv[i]: the ith argument
gcc -c hello.c   hello.c then become hello.o
$ ./a.exe firstarg secondarg thirdarg,    argc = 4
%hd short int
%lf double

Monte Carlo similuation                 
generate random number 0-32767, define result of head(1) if number bigger than 16383, tails(0) otherwise

do fx traia

srand(1);    // set random seed 
for(trail = 0; trail<=ntrail;trail++) 
{
  //initialize current run and max run size for this trail
  //repeat 1000 times
  for(toss = 0; toss <= ntosses; toss+=)
  {
      number = rand()
  }
  
if max_runsize>=threshold
{
    count++;
}
}

%lf (double)count/(double)



9.12
use monte carlo to generate brownian path
to gain probability of Bt > 1

9.17
pointer   FILE *fp   fp = fopen("open.txt", "a") , be careful to "w", it will delete the content exsit
fprintf(fp, "what is this file");
fclose(fp);

char c;  c = '\0', it is null character
intialize a string: initialize char array  char s[30]  = "This is char array"
printf("%s", s),   printf("%x", c): hex value of c
for-loop try to printf null character

operation to string!
be careful to infinite while loop
also do-while loop, slightly different: judge will at the last 
if ()   break;   if()  continue;

pointers
int n;  complier set a storage bace for n, location in memory
int m;
int *p;  pointer,  can store location instead of value     like 0123ACF:n   0123ADC:m
&:reference  *: dereference
p = &n;  store location/address of n in p
p = &m;  store address of m in p now!
I don't want to know address, I want to know the value:
*p <--- value of int in location that p is storing, deferencing a pointer
printf("%p", p);
int i = 63;   p = &i;  *p=193;  printf("%d",i); result will be 193

p points function:
duoble mysquare(double x){return x*x};
double (*p)(double);  pointer that points to a function that return double and has double as an argument
p = &mysquare
printf("%lf",(*p)(x))

integerate
double integerate(double (*f)(double));  // I don't need name for specific function to pass reference to integrate

pass pointer to point function can avoid copy that function and call it over and over again
reset a value in i in sub function, will it change in the main function?? NO!!!!
This is C function use "call by value", function know what the value is, but it doesn't know where the memory location 
of this argument is. So this function can't change this argument in main function(memory).

we need to pass address to C function, pass location/pointer  void function(int *p)
That calls passing a reference "call by reference"

9.19
ODE  dX(t)/dt = f(X(t), t),  velocity depends on position and time
at instant t move by dX(t) in small amount of dt
Euler-Scheme -- numercial solution method:
X(0) = x0
X(delta) = f(X(0),0)*delta
X(2*delta) = X(delta)+f(X(delta),delta)*delta

Stochastic PDE: 
dX(t) = f(X(t),t)dt + g(X(t),t)dB(t)
first item: determinants  second item:random amount B(t), brownian motion. dB(t): dt*jump, change in BM between t to t+dt
dB(t) = B(t+dt)-B(t)

Stochastic Euler Scheme, will produce random realization
X(delta) = X0
X(delta) = f(X(0),0)*delta+g(X(0),0)*sqrt(delta)*sign

dXt=miu*dt+sigma*dB(t)
special case: (1) sigma = 0,  Xt = miu*t
(2) miu = 0, sigma = 1,  Xt = Bt
(3) miu = 0, sigma = 2
(4) miu > 0, sigma > 0  drifting along, random fluctuation. drift and volatility term

don't know array size, want flexible, use malloc
malloc() take n*sizeof(int) as argument.   return void pointer
double *p;  pointer to double
int x[1000];  static allocation of memory
int *p;    p  = (int *)   malloc(1000*sizeof(int))   tells me where is the first int
pointer to unspecified type, then convert   p[0],p[1],...p[999]
free(p);   //free the allocated space for later use
for i in range (1000):
  print(p[i])
pointer don't move, just point p[0] address
after free(p),  p still point same direction, not NULL， but this address is ineffect, can't be used.

memory leak
don't reassign the p to new malloc, or the old assigned memory will lost

rand（）
